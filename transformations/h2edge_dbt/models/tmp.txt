{{ config(materialized='view') }}

WITH latest_course_scrape AS (
    SELECT
        ss.cleaned_name AS school_name,
        MAX(l.log_ts) AS last_scrape_ts
    FROM {{ ref('stg_logs') }} l
    JOIN {{ ref('stg_sources') }} ss ON ss.source_id = l.log_source_id
    WHERE l.log_stage = 2
      AND LOWER(l.log_message) LIKE '%scrape succeeded%'
    GROUP BY ss.cleaned_name
),
latest_log_per_school AS (
    SELECT
        ss.cleaned_name AS school_name,
        l.log_message AS latest_log_message
    FROM (
        SELECT
            ss.cleaned_name,
            l.log_message,
            ROW_NUMBER() OVER (
                PARTITION BY ss.cleaned_name
                ORDER BY l.log_ts DESC
            ) AS rn
        FROM {{ ref('stg_logs') }} l
        JOIN {{ ref('stg_sources') }} ss ON ss.source_id = l.log_source_id
    ) l
    WHERE rn = 1
)

SELECT
    sd.cleaned_name AS school_name,
    sd.schema_count,
    sd.url_count,
    sd.course_count,
    CASE WHEN sd.course_count > 0 THEN 1 ELSE 0 END AS has_courses,
    CAST(lcs.last_scrape_ts AS STRING) AS last_scrape_human,
    CASE
        WHEN sd.course_count > 0 THEN 'Data Present'
        WHEN lcs.last_scrape_ts IS NOT NULL THEN 'Scraped, No Courses'
        WHEN sd.url_count > 0 THEN 'Crawled, Pending Scrape'
        WHEN sd.schema_count > 0 THEN 'Schema Generated'
        ELSE 'Pending'
    END AS summary_status,
    COALESCE(
        llps.latest_log_message,
        CASE
            WHEN sd.course_count > 0 THEN 'Data Present'
            WHEN lcs.last_scrape_ts IS NOT NULL THEN 'Scraped, No Courses'
            WHEN sd.url_count > 0 THEN 'Crawled, Pending Scrape'
            WHEN sd.schema_count > 0 THEN 'Schema Generated'
            ELSE 'Pending'
        END
    ) AS status_indicator,
    lcs.last_scrape_ts
FROM {{ ref('source_data_status') }} sd
LEFT JOIN latest_course_scrape lcs
    ON lcs.school_name = sd.cleaned_name
LEFT JOIN latest_log_per_school llps
    ON llps.school_name = sd.cleaned_name
-- WHERE lcs.last_scrape_ts IS NOT NULL
;
{{ config(materialized='view') }}

WITH source_scrape_complete AS (
    SELECT 
        source_id,
        MAX(log_ts) AS scrape_ts,
        MAX(log_run_id) AS max_run_id
    FROM {{ ref('sources') }} s
    LEFT JOIN {{ ref('logs') }} l
    ON (
        s.source_id = l.log_source_id
        AND l.log_message LIKE '%records scraped'
    )
    GROUP BY s.source_id
),
url_counts AS (
    SELECT
        url_source_id,
        COUNT(*) AS url_count
    FROM {{ ref('stg_urls') }}
    GROUP BY url_source_id
),
course_counts AS (
    SELECT
        course_source_id,
        COUNT(*) AS course_count
    FROM {{ ref('stg_courses') }}
    GROUP BY course_source_id
)

SELECT
    s.cleaned_name,
    s.source_name,
    r.run_id,
    r.run_start_time,
    r.run_end_time,
    ec.extracted_count,
    uc.url_count,
    cc.course_count,
    seml.log_ts AS start_scrape_ts,
    sa.slots_left,
    CAST(ssc.scrape_ts AS STRING) AS courses_extracted_ts
FROM source_scrape_complete ssc
JOIN {{ ref('sources') }} s ON s.source_id = ssc.source_id
LEFT JOIN {{ ref('logs') }} l
  ON (l.log_ts = ssc.scrape_ts
      AND ssc.source_id = l.log_source_id
      AND ssc.max_run_id = l.log_run_id
      AND l.log_message NOT LIKE 'writing records%')
CROSS JOIN LATERAL (
    SELECT 
        TRY_CAST(
            LEFT(
                l.log_message,
                NULLIF(STRPOS(LOWER(l.log_message), ' records scraped'), 0) - 1
            ) AS INT
        ) AS extracted_count
) AS ec
LEFT JOIN {{ ref('logs') }} seml
  ON (seml.log_run_id = l.log_run_id
      AND seml.log_message LIKE '%scrape (slots left%'
      AND ssc.source_id = seml.log_source_id)
CROSS JOIN LATERAL (
    SELECT
        TRY_CAST(
            NULLIF(
                TRIM(
                    SUBSTR(
                        seml.log_message,
                        STRPOS(LOWER(seml.log_message), '(slots left:') + LENGTH('(slots left:'),
                        CASE 
                            WHEN STRPOS(LOWER(seml.log_message), '(slots left:') > 0 
                                 AND STRPOS(')', seml.log_message, STRPOS(LOWER(seml.log_message), '(slots left:')) 
                                     > STRPOS(LOWER(seml.log_message), '(slots left:') + LENGTH('(slots left:')
                            THEN STRPOS(')', seml.log_message, STRPOS(LOWER(seml.log_message), '(slots left:'))
                                 - (STRPOS(LOWER(seml.log_message), '(slots left:') + LENGTH('(slots left:'))
                            ELSE 0
                        END
                    )
                ),
                ''
            ) AS INT
        ) AS slots_left
) AS sa
LEFT JOIN {{ ref('runs') }} r ON r.run_id = ssc.max_run_id
LEFT JOIN url_counts uc ON uc.url_source_id = s.source_id
LEFT JOIN course_counts cc ON cc.course_source_id = s.source_id
WHERE r.run_id IS NOT NULL
;
-- models/marts/source_data_status.sql

{{
  config(
    materialized='view'
  )
}}

WITH schema_counts AS (
  SELECT
    ss.cleaned_name,
    COUNT(*) AS schema_count
  FROM {{
    ref('stg_scraper_schemas')
  }} ssc
  JOIN {{
    ref('stg_sources')
  }} ss
    ON ssc.scraper_schema_source_id = ss.source_id
  GROUP BY ss.cleaned_name
),
url_counts AS (
  SELECT
    ss.cleaned_name,
    COUNT(*) AS url_count
  FROM {{
    ref('stg_urls')
  }} u
  JOIN {{
    ref('stg_sources')
  }} ss
    ON u.url_source_id = ss.source_id
  GROUP BY ss.cleaned_name
),
deduped_courses AS (
  SELECT DISTINCT
    ss.cleaned_name,
    c.course_description,
    c.course_title
  FROM {{
    ref('stg_courses')
  }} c
  JOIN {{
    ref('stg_sources')
  }} ss
    ON c.course_source_id = ss.source_id
),
course_counts AS (
  SELECT
    cleaned_name,
    COUNT(*) AS course_count
  FROM deduped_courses
  GROUP BY cleaned_name
)
SELECT
  s.cleaned_name,
  COALESCE(sc.schema_count, 0) AS schema_count,
  COALESCE(u.url_count, 0) AS url_count,
  COALESCE(c.course_count, 0) AS course_count
FROM (
  SELECT DISTINCT cleaned_name
  FROM {{
    ref('stg_sources')
  }}
) AS s
LEFT JOIN schema_counts sc ON sc.cleaned_name = s.cleaned_name
LEFT JOIN url_counts u ON u.cleaned_name = s.cleaned_name
LEFT JOIN course_counts c ON c.cleaned_name = s.cleaned_name;-- models/staging/stg_taxonomies.sql

SELECT
    taxonomy_id,
    taxonomy_description
FROM
    {{ source('dbo', 'taxonomy01') }}-- models/staging/stg_courses.sql

select
    course_id,
    course_source_id,
    course_title,
    course_description,
    course_code,
    courses_crtd_id,
    courses_crtd_dt,
    courses_updt_id,
    courses_updt_dt,
    courses_table_id

from {{ source('dbo', 'courses') }}-- models/staging/stg_logs.sql

SELECT
    log_id                  AS log_id,
    log_run_id              AS log_run_id,
    log_source_id           AS log_source_id,
    log_stage               AS log_stage,
    log_message             AS log_message,
    log_ts                  AS log_ts,          -- TIMESTAMP
    logs_crtd_dt            AS logs_crtd_dt     -- If you have this column for created datetime
FROM {{ source('dbo', 'logs') }}
-- Add filters or casting if necessary
-- models/staging/stg_scraper_schemas.sql

SELECT
  scraper_schema_id,
  scraper_schema_source_id,
  scraper_schema_json
FROM
  {{ source('dbo', 'scraper_schemas')}}-- models/staging/stg_urls.sql

SELECT
  url_id,
  url_source_id,
  url_link,
  is_target
FROM 
  {{ source('dbo', 'urls')}}-- models/staging/stg_course_taxonomy.sql

SELECT
    course_id,
    taxonomy_id
FROM
    {{ source('dbo', 'course_taxonomy01') }}# models/staging/sources.yml
version: 2

sources:
  - name: dbo
    database: H2EDGE
    schema: dbo
    tables:
      - name: courses
      - name: logs
      - name: flyway_schema_history
      - name: log_stages
      - name: runs
      - name: scraper_schemas
      - name: sources
      - name: urls
      - name: taxonomy01
      - name: course_taxonomy01
      - name: universities-- models/staging/stg_courses.sql

WITH ranked_matches AS (
  SELECT
    s.cleaned_name,
    s.source_name,
    s.source_id,
    u.instnm,
    s.src_host,
    u.uni_host,
    u.unitid,
    u.universities_table_id,
    ROW_NUMBER() OVER (
      PARTITION BY s.source_name
      ORDER BY
        CASE
          WHEN s.src_host = u.uni_host
            OR s.src_host LIKE '%.' + u.uni_host
          THEN 1    -- prioritize URL match
          ELSE 2    -- fallback to name match
        END
    ) AS rn
  FROM {{ source('dbo', 'sources') }} AS s
  LEFT JOIN {{ source('dbo', 'universities') }} AS u
    ON s.src_host = u.uni_host
    OR s.src_host LIKE '%.' + u.uni_host
    OR LOWER(s.cleaned_name) LIKE '%' + LOWER(u.instnm) + '%'
)
SELECT *
FROM ranked_matches
WHERE rn = 1;-- models/staging/stg_sources.sql

SELECT
    source_id,
    source_name,
    cleaned_name
FROM
    {{ source('dbo', 'sources') }}